HTTP 的服务器缓存功能主要由代理服务器来实现（即缓存代理）
# 缓存代理服务
![](https://static001.geekbang.org/resource/image/5e/c2/5e8d10b5758685850aeed2a473a6cdc2.png)

代理服务收到源服务器发来的响应数据后需要做两件事。第一个当然是把报文转发给客户端，而第二个就是把报文存入自己的 Cache 里。

下一次再有相同的请求，代理服务器就可以直接发送 304 或者缓存数据，不必再从源服务器那里获取。这样就降低了客户端的等待时间，同时节约了源服务器的网络带宽。

在 HTTP 的缓存体系中，缓存代理的身份十分特殊，它“既是客户端，又是服务器”，同时也“既不是客户端，又不是服务器”。

# 源服务器的缓存控制
4 种服务器端的“Cache-Control”属性：max-age、no-store、no-cache 和 must-revalidate，可以约束客户端，也可以约束代理。

但客户端和代理是不一样的，客户端的缓存只是用户自己使用，而代理的缓存可能会为非常多的客户端提供服务。所以，需要对它的缓存再多一些限制条件。

首先，我们要**区分客户端上的缓存和代理上的缓存**，可以使用两个新属性“private”和“public”。“private”表示缓存只能在客户端保存，是用户“私有”的，不能放在代理上与别人共享。而“public”的意思就是缓存完全开放，谁都可以存，谁都可以用。

其次，**缓存失效后的重新验证也要区分开**（即使用条件请求“Last-modified”和“ETag”），“must-revalidate”是只要过期就必须回源服务器验证，而新的“proxy-revalidate”只要求代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了。

再次，**缓存的生存时间可以使用新的“s-maxage”**（s 是 share 的意思，注意 maxage 中间没有“-”），只限定在代理上能够存多久，而客户端仍然使用“max-age”。

最后，还有一个代理专用的属性“no-transform”，禁止代理服务器改变数据。

下面的流程图是完整的**服务器端缓存控制策略**，可以同时控制客户端和代理

![](https://static001.geekbang.org/resource/image/09/35/09266657fa61d0d1a720ae3360fe9535.png)

源服务器在设置完“Cache-Control”后必须要为报文加上“Last-modified”或“ETag”字段。否则，客户端和代理后面就无法使用条件请求来验证缓存是否有效，也就不会有 304 缓存重定向。

# 客户端的缓存控制
**客户端在 HTTP 缓存体系里要面对的是代理和源服务器**，也必须区别对待。
![](https://static001.geekbang.org/resource/image/47/92/47c1a69c800439e478c7a4ed40b8b992.png)

关于缓存的生存时间，多了两个新属性“**max-stale**”和“**min-fresh**”

“max-stale”的意思是如果代理上的缓存过期了也可以接受，但不能过期太多，超过 x 秒也会不要。

“min-fresh”的意思是缓存必须有效，而且必须在 x 秒后依然有效。

还有一个特别的“**only-if-cached**”属性，表示只接受代理缓存的数据，不接受源服务器的响应。如果代理上没有缓存或者缓存过期，就应该给客户端返回一个 504（Gateway Timeout）。

# 其他问题
 **Vary** 字段是内容协商的结果，相当于报文的一个版本标记。
 
 同一个请求，经过内容协商后可能会有不同的字符集、编码、浏览器等版本。比如，“Vary: Accept-Encoding”“Vary: User-Agent”，缓存代理必须要存储这些不同的版本。
 
 当再收到相同的请求时，代理就读取缓存里的“Vary”，对比请求头里相应的“ Accept-Encoding”“User-Agent”等字段，如果和上一个请求的完全匹配，比如都是“gzip”“Chrome”，就表示版本一致，可以返回缓存的数据。
 
 “**Purge**”，也就是“缓存清理”，它对于代理也是非常重要的功能，例如：
 - 过期的数据应该及时淘汰，避免占用空间；
 - 源站的资源有更新，需要删除旧版本，主动换成最新版（即刷新）
 - 有时候会缓存了一些本不该存储的信息，例如网络谣言或者危险链接，必须尽快把它们删除。
 
清理缓存的方法有很多，比较常用的一种做法是使用自定义请求方法“PURGE”，发给代理服务器，要求删除 URI 对应的缓存数据。
