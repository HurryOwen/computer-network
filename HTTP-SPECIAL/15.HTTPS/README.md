# 安全的四个特性
- 机密性
- 完整性
- 身份认证
- 不可否认

HTTPS 具有以上四个特性，它把下层的底层传输协议由 TCP/IP 换成了 SSL/TLS，由 “**HTTP over TCP/IP**” 变成了 “**HTTP over SSL/TLS**”。收发报文不再使用 Socket API，而是调用专门的安全接口。
![https](https://static001.geekbang.org/resource/image/50/a3/50d57e18813e18270747806d5d73f0a3.png)

# SSL / TLS
SSL 即安全套接层（Secure Sockets Layer）,发展到 V3 时更名为TLS（传输层安全，Transport Layer Security）。

TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。

浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。

**密码套件命名规律：**“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”。

例如：“ECDHE-RSA-AES256-GCM-SHA384”，表示“握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”

**OpenSSL**:是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。

# 对称加密和非对称加密——机密性
## 对称加密
加密和解密时使用的密钥都是同一个，是“对称”的。
![](https://static001.geekbang.org/resource/image/8f/49/8feab67c25a534f8c72077680927ab49.png)

### 对称加密算法：
- **AES**，高级加密标准（Advanced Encryption Standard），是应用最广泛的对称加密算法。
- **ChaCha20**，Google 设计的另一种加密算法，密钥长度固定为 256 位。

### 加密分组模式
对称算法还有一个“分组模式”的概念，它可以让算法用固定长度的密钥加密任意长度的明文，把小秘密（即密钥）转化为大秘密（即密文）。

最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是：
- **GCM**
- **CCM**
- **Poly1305**

把上面这些组合起来，就可以得到 TLS 密码套件中定义的对称加密算法。

比如，AES128-GCM，意思是密钥长度为 128 位的 AES 算法，使用的分组模式是 GCM；

## 非对称加密
对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“**密钥交换**”。

非对称加密有两个密钥，一个叫“**公钥**”（public key），一个叫“**私钥**”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。

公钥和私钥有个特别的“**单向**”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。
![](https://static001.geekbang.org/resource/image/89/17/89344c2e493600b486d5349a84318417.png)

### 非对称加密算法：
- **RSA**，安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料。
- **ECC**，基于“椭圆曲线离散对数”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。

比起 RSA，**ECC 在安全强度和性能上都有明显的优势**。160 位的 ECC 相当于 1024 位的 RSA，而 224 位的 ECC 则相当于 2048 位的 RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，对于现在的移动互联网非常有吸引力。

## 混合加密
 虽然非对称加密保证了安全，但是加密解密速度很慢，所以 TLS 使用**混合加密方式**。
 
 即在通信开始时，用非对称算法解决秘钥交换问题。
 
 然后用随机数产生对称算法使用的“**会话密钥**”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。
 
 对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。
 ![](https://static001.geekbang.org/resource/image/e4/85/e41f87110aeea3e548d58cc35a478e85.png)
 
 # 摘要算法——完整性
 摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。
 
 可以把摘要算法理解成一种特殊的压缩算法，能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。
 
 换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。
 
 ![](https://static001.geekbang.org/resource/image/28/d8/2865d2c77466efb7a480833bcb27f9d8.png)
 
 因为摘要算法对输入具有“**单向性**”和“**雪崩效应**”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数。
 
 真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。
 
 ![](https://static001.geekbang.org/resource/image/c2/96/c2e10e9afa1393281b5633b1648f2696.png)
 
 # 数字签名——身份认证和不可否认
 使用非对称加密里的“**私钥**”，再加上摘要算法，就能够实现“**数字签名**”，同时实现“身份认证”和“不可否认”。
 
  因为非对称加密效率太低，所以只用私钥加密原文的摘要，得到的数字签名也很小，方便保管和传输。
  
  签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的。
  
  ![](https://static001.geekbang.org/resource/image/84/d2/84a79826588ca35bf6ddcade027597d2.png)
 
 只要你和网站互相交换公钥，就可以用“签名”和“验签”来确认消息的真实性，因为私钥保密，黑客不能伪造签名，就能够保证通信双方的身份。
 
 # 数字证书和 CA
 综合使用对称加密、非对称加密和摘要算法，我们已经实现了安全的四大特性，但是还有个“**公钥的信任**”问题。因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段。
 
 解决办法是找一个公认的可信第三方，也就是我们常说的 **CA**（Certificate Authority，证书认证机构）。
 
 CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“**数字证书**”（Certificate）。
 
 CA 通过证书信任链证明自己，小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 **Root CA**，就只能自己证明自己了，这个就叫“**自签名证书**”（Self-Signed Certificate）或者“**根证书**”（Root Certificate）。
 
 有了这个证书体系，操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的。
 
 ![](https://static001.geekbang.org/resource/image/8f/9c/8f0813e9555ba1a40bd2170734aced9c.png)
 
 # HTTPS 建立连接
 ## TLS 协议的组成
 - **记录协议**（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。
 - **警报协议**（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。
 - **握手协议**（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。
 - **变更密码规范协议**（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。
  
  下面的这张图简要地描述了 TLS 的握手过程，其中每一个“框”都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4 个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

  ![](https://static001.geekbang.org/resource/image/69/6c/69493b53f1b1d540acf886ebf021a26c.png)

  ## ECDHE 握手过程
  ![](https://static001.geekbang.org/resource/image/9c/1e/9caba6d4b527052bbe7168ed4013011e.png)

  ## RSA 握手过程
  ![](https://static001.geekbang.org/resource/image/cb/d2/cb9a89055eadb452b7835ba8db7c3ad2.png)

  大体的流程没有变，只是“Pre-Master”不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client Key Exchange”消息发给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。

  # 总结
  - HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接；
  - 握手的目标是安全地交换对称密钥，需要三个随机数，第三个随机数“Pre-Master”必须加密传输，绝对不能让黑客破解；
  - “Hello”消息交换随机数，“Key Exchange”消息交换“Pre-Master”；
  - “Change Cipher Spec”之前传输的都是明文，之后都是对称密钥加密的密文。
 
 
 